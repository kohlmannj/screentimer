{"version":3,"sources":["../src/index.js"],"names":["isInViewport","defaults","callback","lookInterval","reportInterval","elem","distance","getBoundingClientRect","top","left","bottom","window","innerHeight","document","documentElement","clientHeight","right","innerWidth","clientWidth","Screentimer","element","threshold","handlePageVisibilityChange","stopTimer","hidden","startTimer","look","onScreen","counter","report","count","seconds","looker","reporter","started","Error","addEventListener","setInterval","clearInterval","removeEventListener"],"mappings":"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","file":"index.js","sourcesContent":["export const defaults = {\n  callback: () => {},\n  lookInterval: 1,\n  reportInterval: 10,\n};\n\n/*! isInViewport.js | (c) 2017 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/isInViewport */\n/**\n * Determine if an element is in the viewport\n * @param  {Node}    elem The element\n * @return {Boolean}      Returns true if element is in the viewport\n */\nexport function isInViewport(elem) {\n  var distance = elem.getBoundingClientRect();\n  return (\n      distance.top >= 0 &&\n      distance.left >= 0 &&\n      distance.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n      distance.right <= (window.innerWidth || document.documentElement.clientWidth)\n  );\n}\n\nexport default class Screentimer {\n  constructor(element, callback, { lookInterval, reportInterval, threshold } = {}) {\n    this.looker = null;\n    this.reporter = null;\n\n    this.counter = 0;\n    this.started = false;\n\n    this.element = element;\n\n    if (!this.element) {\n      throw new Error('Screentimer constructor: `element` argument is falsy');\n    }\n\n    this.callback = callback || defaults.callback;\n    this.lookInterval = lookInterval || defaults.lookInterval;\n    this.reportInterval = reportInterval || defaults.reportInterval;\n    this.threshold = threshold || defaults.threshold;\n\n    this.startTimer();\n\n    // Attach window event listener to handle timer starts and stops based on page visibility\n    window.addEventListener('visibilitychange', this.handlePageVisibilityChange);\n  }\n\n  handlePageVisibilityChange = () => {\n    this.stopTimer();\n\n    if (!document.hidden) {\n      this.startTimer();\n    }\n  };\n\n  onScreen() {\n    const element = typeof this.element === 'function' ? this.element() : this.element;\n\n    if (!element) {\n      return false;\n    }\n\n    return isInViewport(element);\n  }\n\n  look = () => {\n    if (this.onScreen()) {\n      this.counter += 1;\n    }\n  };\n\n  report = () => {\n    if (this.counter > 0) {\n      const count = this.counter;\n      // Reset `this.counter` since we'll have reported the current number of intervals since the\n      // last call to report().\n      this.counter = 0;\n\n      if (typeof this.callback === 'function') {\n        this.callback({ count, seconds: count * this.lookInterval });\n      }\n    }\n  }\n\n  startTimer() {\n    if (!this.started) {\n      this.started = true;\n    }\n\n    this.looker = setInterval(this.look, this.lookInterval * 1000)\n    this.reporter = setInterval(this.report, this.reportInterval * 1000);\n  }\n\n  stopTimer() {\n    clearInterval(this.looker);\n    clearInterval(this.reporter);\n  }\n\n  reset() {\n    this.stopTimer();\n    this.counter = 0;\n    this.startTimer();\n  }\n\n  destroy() {\n    this.stopTimer();\n    window.removeEventListener('visibilitychange', this.handlePageVisibilityChange);\n  }\n}\n"]}