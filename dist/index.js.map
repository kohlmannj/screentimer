{"version":3,"sources":["../src/index.js"],"names":["calculateFractionalVisibility","defaults","callback","lookInterval","reportInterval","threshold","element","windowHeight","window","innerHeight","docScroll","pageYOffset","divPosition","offsetTop","divHeight","getBoundingClientRect","height","hiddenBefore","hiddenAfter","result","Screentimer","handlePageVisibilityChange","stopTimer","document","hidden","startTimer","look","onScreen","counter","report","count","seconds","looker","reporter","started","Error","addEventListener","force","setInterval","clearInterval","removeEventListener"],"mappings":";;;;;;;;;;;;;;;;;;UAQgBA,6B,GAAAA,6B;;;;;;;;;;;;;;;;;;;;;;;;;;AART,MAAMC,8BAAW;AACtBC,cAAU,oBAAM,CAAE,CADI;AAEtBC,kBAAc,CAFQ;AAGtBC,oBAAgB,EAHM;AAItBC,eAAW;AAJW,GAAjB;;AAOP;AACO,WAASL,6BAAT,CAAuCM,OAAvC,EAAgD;AACrD,QAAMC,eAAeC,OAAOC,WAA5B;AACA,QAAMC,YAAYC,WAAlB;AACA,QAAMC,cAAcN,QAAQO,SAA5B;AACA,QAAMC,YAAYR,QAAQS,qBAAR,GAAgCC,MAAlD;AACA,QAAMC,eAAeP,YAAYE,WAAjC;AACA,QAAMM,cAAeN,cAAcE,SAAf,IAA6BJ,YAAYH,YAAzC,CAApB;;AAEA,QAAKG,YAAYE,cAAcE,SAA3B,IAA0CF,cAAcF,YAAYH,YAAxE,EAAuF;AACnF,aAAO,CAAP;AACH,KAFD,MAEO;AACH,UAAIY,SAAS,CAAb;;AAEA,UAAIF,eAAe,CAAnB,EAAsB;AAClBE,kBAAUF,eAAeH,SAAzB;AACH;;AAED,UAAII,cAAc,CAAlB,EAAqB;AACjBC,kBAAUD,cAAcJ,SAAxB;AACH;;AAED,aAAOK,MAAP;AACH;AACF;;MAEoBC,W;AACnB,yBAAYd,OAAZ,EAAqBJ,QAArB,EAAiF;AAAA;;AAAA,qFAAJ,EAAI;AAAA,UAAhDC,YAAgD,QAAhDA,YAAgD;AAAA,UAAlCC,cAAkC,QAAlCA,cAAkC;AAAA,UAAlBC,SAAkB,QAAlBA,SAAkB;;AAAA;;AAAA,WAwBjFgB,0BAxBiF,GAwBpD,YAAM;AACjC,cAAKC,SAAL;;AAEA,YAAI,CAACC,SAASC,MAAd,EAAsB;AACpB,gBAAKC,UAAL;AACD;AACF,OA9BgF;;AAAA,WA0CjFC,IA1CiF,GA0C1E,YAAM;AACX,YAAI,MAAKC,QAAL,EAAJ,EAAqB;AACnB,gBAAKC,OAAL,IAAgB,CAAhB;AACD;AACF,OA9CgF;;AAAA,WAgDjFC,MAhDiF,GAgDxE,YAAM;AACb,YAAI,MAAKD,OAAL,GAAe,CAAnB,EAAsB;AACpB,cAAME,QAAQ,MAAKF,OAAnB;AACA;AACA;AACA,gBAAKA,OAAL,GAAe,CAAf;;AAEA,cAAI,OAAO,MAAK1B,QAAZ,KAAyB,UAA7B,EAAyC;AACvC,kBAAKA,QAAL,CAAc,EAAE4B,YAAF,EAASC,SAASD,QAAQ,MAAK3B,YAA/B,EAAd;AACD;AACF;AACF,OA3DgF;;AAC/E,WAAK6B,MAAL,GAAc,IAAd;AACA,WAAKC,QAAL,GAAgB,IAAhB;;AAEA,WAAKL,OAAL,GAAe,CAAf;AACA,WAAKM,OAAL,GAAe,KAAf;;AAEA,WAAK5B,OAAL,GAAeA,OAAf;;AAEA,UAAI,CAAC,KAAKA,OAAV,EAAmB;AACjB,cAAM,IAAI6B,KAAJ,CAAU,sDAAV,CAAN;AACD;;AAED,WAAKjC,QAAL,GAAgBA,YAAYD,SAASC,QAArC;AACA,WAAKC,YAAL,GAAoBA,gBAAgBF,SAASE,YAA7C;AACA,WAAKC,cAAL,GAAsBA,kBAAkBH,SAASG,cAAjD;AACA,WAAKC,SAAL,GAAiBA,aAAaJ,SAASI,SAAvC;;AAEA,WAAKoB,UAAL;;AAEA;AACAjB,aAAO4B,gBAAP,CAAwB,kBAAxB,EAA4C,KAAKf,0BAAjD;AACD;;;;iCAUU;AACT,YAAMf,UAAU,OAAO,KAAKA,OAAZ,KAAwB,UAAxB,GAAqC,KAAKA,OAAL,EAArC,GAAsD,KAAKA,OAA3E;;AAEA,YAAI,CAACA,OAAL,EAAc;AACZ,iBAAO,KAAP;AACD;;AAED,eAAON,8BAA8BM,OAA9B,KAA0C,KAAKD,SAAtD;AACD;;;mCAqByB;AAAA,YAAfgC,KAAe,uEAAP,KAAO;;AACxB,YAAIA,SAAS,CAAC,KAAKH,OAAnB,EAA4B;AAC1B,eAAKF,MAAL,GAAcM,YAAY,KAAKZ,IAAjB,EAAuB,KAAKvB,YAAL,GAAoB,IAA3C,CAAd;AACA,eAAK8B,QAAL,GAAgBK,YAAY,KAAKT,MAAjB,EAAyB,KAAKzB,cAAL,GAAsB,IAA/C,CAAhB;AACA,eAAK8B,OAAL,GAAe,IAAf;AACD;AACF;;;kCAEwB;AAAA,YAAfG,KAAe,uEAAP,KAAO;;AACvB,YAAIA,SAAS,KAAKH,OAAlB,EAA2B;AACzBK,wBAAc,KAAKP,MAAnB;AACAO,wBAAc,KAAKN,QAAnB;AACA,eAAKC,OAAL,GAAe,KAAf;AACD;AACF;;;8BAEO;AACN;AACA,aAAKZ,SAAL,CAAe,IAAf;AACA,aAAKM,OAAL,GAAe,CAAf;AACA,aAAKH,UAAL,CAAgB,IAAhB;AACD;;;gCAES;AACR,aAAKH,SAAL;AACAd,eAAOgC,mBAAP,CAA2B,kBAA3B,EAA+C,KAAKnB,0BAApD;AACD;;;;;;oBAxFkBD,W","file":"index.js","sourcesContent":["export const defaults = {\n  callback: () => {},\n  lookInterval: 1,\n  reportInterval: 10,\n  threshold: 0.5,\n};\n\n// @see https://stackoverflow.com/a/33860876\nexport function calculateFractionalVisibility(element) {\n  const windowHeight = window.innerHeight;\n  const docScroll = pageYOffset;\n  const divPosition = element.offsetTop;\n  const divHeight = element.getBoundingClientRect().height;\n  const hiddenBefore = docScroll - divPosition;\n  const hiddenAfter = (divPosition + divHeight) - (docScroll + windowHeight);\n\n  if ((docScroll > divPosition + divHeight) || (divPosition > docScroll + windowHeight)) {\n      return 0;\n  } else {\n      var result = 1;\n\n      if (hiddenBefore > 0) {\n          result -= hiddenBefore / divHeight;\n      }\n\n      if (hiddenAfter > 0) {\n          result -= hiddenAfter / divHeight;\n      }\n\n      return result;\n  }\n}\n\nexport default class Screentimer {\n  constructor(element, callback, { lookInterval, reportInterval, threshold } = {}) {\n    this.looker = null;\n    this.reporter = null;\n\n    this.counter = 0;\n    this.started = false;\n\n    this.element = element;\n\n    if (!this.element) {\n      throw new Error('Screentimer constructor: `element` argument is falsy');\n    }\n\n    this.callback = callback || defaults.callback;\n    this.lookInterval = lookInterval || defaults.lookInterval;\n    this.reportInterval = reportInterval || defaults.reportInterval;\n    this.threshold = threshold || defaults.threshold;\n\n    this.startTimer();\n\n    // Attach window event listener to handle timer starts and stops based on page visibility\n    window.addEventListener('visibilitychange', this.handlePageVisibilityChange);\n  }\n\n  handlePageVisibilityChange = () => {\n    this.stopTimer();\n\n    if (!document.hidden) {\n      this.startTimer();\n    }\n  };\n\n  onScreen() {\n    const element = typeof this.element === 'function' ? this.element() : this.element;\n    \n    if (!element) {\n      return false;\n    }\n  \n    return calculateFractionalVisibility(element) >= this.threshold;\n  }\n\n  look = () => {\n    if (this.onScreen()) {\n      this.counter += 1;\n    }\n  };\n\n  report = () => {\n    if (this.counter > 0) {\n      const count = this.counter;\n      // Reset `this.counter` since we'll have reported the current number of intervals since the\n      // last call to report().\n      this.counter = 0;\n\n      if (typeof this.callback === 'function') {\n        this.callback({ count, seconds: count * this.lookInterval });\n      }\n    }\n  }\n\n  startTimer(force = false) {\n    if (force || !this.started) {\n      this.looker = setInterval(this.look, this.lookInterval * 1000);\n      this.reporter = setInterval(this.report, this.reportInterval * 1000);\n      this.started = true;\n    }\n  }\n\n  stopTimer(force = false) {\n    if (force || this.started) {\n      clearInterval(this.looker);\n      clearInterval(this.reporter);\n      this.started = false;\n    }\n  }\n\n  reset() {\n    // Pass `true` to both stopTimer() and startTimer() to `force` them\n    this.stopTimer(true);\n    this.counter = 0;\n    this.startTimer(true);\n  }\n\n  destroy() {\n    this.stopTimer();\n    window.removeEventListener('visibilitychange', this.handlePageVisibilityChange);\n  }\n}\n"]}