{"version":3,"sources":["../src/index.js"],"names":["calculateFractionalVisibility","defaults","callback","lookInterval","reportInterval","threshold","element","windowHeight","window","innerHeight","docScroll","pageYOffset","divPosition","offsetTop","parentElement","getBoundingClientRect","divHeight","height","hiddenBefore","hiddenAfter","result","Screentimer","handlePageVisibilityChange","stopTimer","document","hidden","startTimer","look","onScreen","counter","report","count","seconds","looker","reporter","started","Error","addEventListener","force","setInterval","clearInterval","removeEventListener"],"mappings":"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","file":"index.js","sourcesContent":["export const defaults = {\n  callback: () => {},\n  lookInterval: 1,\n  reportInterval: 10,\n  threshold: 0.5,\n};\n\n// @see https://stackoverflow.com/a/33860876\nexport function calculateFractionalVisibility(element) {\n  const windowHeight = window.innerHeight;\n  const docScroll = pageYOffset;\n  const divPosition = element.offsetTop + element.parentElement ? element.parentElement.offsetTop : 0;\n  const { height: divHeight } = element.getBoundingClientRect();\n  const hiddenBefore = docScroll - divPosition;\n  const hiddenAfter = (divPosition + divHeight) - (docScroll + windowHeight);\n\n  if ((docScroll > divPosition + divHeight) || (divPosition > docScroll + windowHeight)) {\n    return 0;\n  } else {\n    let result = 1;\n\n    if (hiddenBefore > 0) {\n        result -= hiddenBefore / divHeight;\n    }\n\n    if (hiddenAfter > 0) {\n        result -= hiddenAfter / divHeight;\n    }\n\n    return result;\n  }\n}\n\nexport default class Screentimer {\n  constructor(element, callback, { lookInterval, reportInterval, threshold } = {}) {\n    this.looker = null;\n    this.reporter = null;\n\n    this.counter = 0;\n    this.started = false;\n\n    this.element = element;\n\n    if (!this.element) {\n      throw new Error('Screentimer constructor: `element` argument is falsy');\n    }\n\n    this.callback = callback || defaults.callback;\n    this.lookInterval = lookInterval || defaults.lookInterval;\n    this.reportInterval = reportInterval || defaults.reportInterval;\n    this.threshold = threshold || defaults.threshold;\n\n    this.startTimer();\n\n    // Attach window event listener to handle timer starts and stops based on page visibility\n    window.addEventListener('visibilitychange', this.handlePageVisibilityChange);\n  }\n\n  handlePageVisibilityChange = () => {\n    this.stopTimer();\n\n    if (!document.hidden) {\n      this.startTimer();\n    }\n  };\n\n  onScreen() {\n    const element = typeof this.element === 'function' ? this.element() : this.element;\n    \n    if (!element) {\n      return false;\n    }\n  \n    return calculateFractionalVisibility(element) >= this.threshold;\n  }\n\n  look = () => {\n    if (this.onScreen()) {\n      this.counter += 1;\n    }\n  };\n\n  report = () => {\n    if (this.counter > 0) {\n      const count = this.counter;\n      // Reset `this.counter` since we'll have reported the current number of intervals since the\n      // last call to report().\n      this.counter = 0;\n\n      if (typeof this.callback === 'function') {\n        this.callback({ count, seconds: count * this.lookInterval });\n      }\n    }\n  }\n\n  startTimer(force = false) {\n    if (force || !this.started) {\n      this.looker = setInterval(this.look, this.lookInterval * 1000);\n      this.reporter = setInterval(this.report, this.reportInterval * 1000);\n      this.started = true;\n    }\n  }\n\n  stopTimer(force = false) {\n    if (force || this.started) {\n      clearInterval(this.looker);\n      clearInterval(this.reporter);\n      this.started = false;\n    }\n  }\n\n  reset() {\n    // Pass `true` to both stopTimer() and startTimer() to `force` them\n    this.stopTimer(true);\n    this.counter = 0;\n    this.startTimer(true);\n  }\n\n  destroy() {\n    this.stopTimer();\n    window.removeEventListener('visibilitychange', this.handlePageVisibilityChange);\n  }\n}\n"]}