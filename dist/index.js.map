{"version":3,"sources":["../src/index.js"],"names":["isInViewport","defaults","callback","lookInterval","reportInterval","element","range","top","height","wH","window","innerHeight","bcr","getBoundingClientRect","pageYOffset","bottom","Screentimer","handlePageVisibilityChange","stopTimer","document","hidden","startTimer","look","onScreen","counter","report","count","seconds","looker","reporter","started","Error","addEventListener","inViewport","force","setInterval","clearInterval","removeEventListener"],"mappings":"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","file":"index.js","sourcesContent":["export const defaults = {\n  callback: () => {},\n  lookInterval: 1,\n  reportInterval: 10,\n};\n\nexport function isInViewport(element) {\n  if (!element) {\n    return false;\n  }\n\n  const range = { top: 0, height: 1 };\n  const wH = window.innerHeight;\n  const bcr = element.getBoundingClientRect();\n  const top = bcr.top + pageYOffset;\n  const height = bcr.height;\n  const bottom = top + height;\n\n  return (\n    pageYOffset + (wH * (range.top + range.height)) > top &&\n    pageYOffset + (wH * range.top) < bottom\n  );\n}\n\nexport default class Screentimer {\n  constructor(element, callback, { lookInterval, reportInterval } = {}) {\n    this.looker = null;\n    this.reporter = null;\n\n    this.counter = 0;\n    this.started = false;\n\n    this.element = element;\n\n    if (!this.element) {\n      throw new Error('Screentimer constructor: `element` argument is falsy');\n    }\n\n    this.callback = callback || defaults.callback;\n    this.lookInterval = lookInterval || defaults.lookInterval;\n    this.reportInterval = reportInterval || defaults.reportInterval;\n\n    this.startTimer();\n\n    // Attach window event listener to handle timer starts and stops based on page visibility\n    window.addEventListener('visibilitychange', this.handlePageVisibilityChange);\n  }\n\n  handlePageVisibilityChange = () => {\n    this.stopTimer();\n\n    if (!document.hidden) {\n      this.startTimer();\n    }\n  };\n\n  onScreen() {\n    const element = typeof this.element === 'function' ? this.element() : this.element;\n\n    if (!element) {\n      return false;\n    }\n    \n    const inViewport = isInViewport(element);\n\n    return isInViewport(element);\n  }\n\n  look = () => {\n    if (this.onScreen()) {\n      this.counter += 1;\n    }\n  };\n\n  report = () => {\n    if (this.counter > 0) {\n      const count = this.counter;\n      // Reset `this.counter` since we'll have reported the current number of intervals since the\n      // last call to report().\n      this.counter = 0;\n\n      if (typeof this.callback === 'function') {\n        this.callback({ count, seconds: count * this.lookInterval });\n      }\n    }\n  }\n\n  startTimer(force = false) {\n    if (force || !this.started) {\n      this.looker = setInterval(this.look, this.lookInterval * 1000);\n      this.reporter = setInterval(this.report, this.reportInterval * 1000);\n      this.started = true;\n    }\n  }\n\n  stopTimer(force = false) {\n    if (force || this.started) {\n      clearInterval(this.looker);\n      clearInterval(this.reporter);\n      this.started = false;\n    }\n  }\n\n  reset() {\n    // Pass `true` to both stopTimer() and startTimer() to `force` them\n    this.stopTimer(true);\n    this.counter = 0;\n    this.startTimer(true);\n  }\n\n  destroy() {\n    this.stopTimer();\n    window.removeEventListener('visibilitychange', this.handlePageVisibilityChange);\n  }\n}\n"]}